/**
 * Database Access Example
 *
 * Demonstrates polyglot database access:
 * - TypeScript for SQL queries (fast)
 * - Python for data analysis (powerful)
 * - Shared database connection
 */

import FastAPI from '../src/fastapi';
import { createModel, Field } from '../src/models';
import { APIRouter } from '../src/routing';

const app = new FastAPI({
  title: 'Database API',
  description: 'Polyglot database access with TypeScript + Python',
  version: '1.0.0',
});

// Mock database (in production would use real PostgreSQL/MySQL)
interface DBConnection {
  query<T>(sql: string, params?: any[]): Promise<T[]>;
  execute(sql: string, params?: any[]): Promise<number>;
  transaction<T>(callback: () => Promise<T>): Promise<T>;
}

const db: DBConnection = {
  async query<T>(sql: string, params?: any[]): Promise<T[]> {
    // Simulate database query
    await new Promise(resolve => setTimeout(resolve, 10));

    // Mock data
    if (sql.includes('SELECT * FROM users')) {
      return [
        { id: 1, email: 'user1@example.com', age: 25, created_at: new Date() },
        { id: 2, email: 'user2@example.com', age: 30, created_at: new Date() },
        { id: 3, email: 'user3@example.com', age: 35, created_at: new Date() },
      ] as T[];
    }

    return [] as T[];
  },

  async execute(sql: string, params?: any[]): Promise<number> {
    await new Promise(resolve => setTimeout(resolve, 5));
    return 1;
  },

  async transaction<T>(callback: () => Promise<T>): Promise<T> {
    try {
      return await callback();
    } catch (err) {
      throw err;
    }
  },
};

// Python data analysis (simulated)
const PythonDataAnalysis = {
  async analyzeAgeDistribution(users: any[]): Promise<any> {
    // In production: import from python/analytics.py
    // python.Analytics.analyze_age_distribution(users)

    const ages = users.map(u => u.age);
    const mean = ages.reduce((a, b) => a + b, 0) / ages.length;
    const sorted = [...ages].sort((a, b) => a - b);
    const median = sorted[Math.floor(sorted.length / 2)];

    return {
      count: ages.length,
      mean,
      median,
      min: Math.min(...ages),
      max: Math.max(...ages),
      distribution: {
        '20-29': ages.filter(a => a >= 20 && a < 30).length,
        '30-39': ages.filter(a => a >= 30 && a < 40).length,
        '40-49': ages.filter(a => a >= 40 && a < 50).length,
      },
      analyzer: 'python-numpy',
    };
  },

  async detectAnomalies(data: any[]): Promise<any> {
    // In production: use Python scikit-learn for anomaly detection
    return {
      anomalies: [],
      threshold: 2.5,
      method: 'isolation-forest',
    };
  },

  async generateReport(users: any[]): Promise<string> {
    // In production: use Python pandas for report generation
    return `User Analysis Report
===================
Total Users: ${users.length}
Average Age: ${users.reduce((sum, u) => sum + u.age, 0) / users.length}

Generated by Python Pandas
`;
  },
};

// Define models
const UserModel = createModel('User', {
  fields: {
    id: Field({ type: 'number' }),
    email: Field({ type: 'string', required: true }),
    age: Field({ type: 'number', min: 0, max: 150 }),
    created_at: Field({ type: 'string' }),
  },
});

// Database router
const dbRouter = new APIRouter({ prefix: '/db', tags: ['Database'] });

/**
 * Get all users (TypeScript query)
 */
dbRouter.get('/users', async (req) => {
  const limit = parseInt(req.query.limit || '10');
  const offset = parseInt(req.query.offset || '0');

  // TypeScript: Fast SQL query
  const users = await db.query<any>(
    'SELECT * FROM users LIMIT $1 OFFSET $2',
    [limit, offset]
  );

  return {
    users,
    count: users.length,
    query_engine: 'typescript',
  };
}, {
  summary: 'Get users (TypeScript SQL)',
});

/**
 * Get user by ID (TypeScript query)
 */
dbRouter.get('/users/{id}', async (req) => {
  const id = parseInt(req.params.id);

  const users = await db.query<any>(
    'SELECT * FROM users WHERE id = $1',
    [id]
  );

  if (users.length === 0) {
    throw { status_code: 404, detail: 'User not found' };
  }

  return users[0];
}, {
  summary: 'Get user by ID',
});

/**
 * Create user with transaction (TypeScript)
 */
dbRouter.post('/users', async (req) => {
  const userData = req.body;

  // TypeScript: Database transaction
  const result = await db.transaction(async () => {
    // Insert user
    await db.execute(
      'INSERT INTO users (email, age) VALUES ($1, $2)',
      [userData.email, userData.age]
    );

    // Log activity
    await db.execute(
      'INSERT INTO activity_log (action, user_email) VALUES ($1, $2)',
      ['user_created', userData.email]
    );

    return {
      id: Math.floor(Math.random() * 1000),
      ...userData,
      created_at: new Date().toISOString(),
    };
  });

  return result;
}, {
  summary: 'Create user with transaction',
  status_code: 201,
});

/**
 * Analyze users (TypeScript query + Python analysis)
 */
dbRouter.get('/users/analyze', async () => {
  // TypeScript: Fast database query
  const users = await db.query<any>('SELECT * FROM users');

  // Python: Advanced statistical analysis
  const analysis = await PythonDataAnalysis.analyzeAgeDistribution(users);

  // Python: Anomaly detection
  const anomalies = await PythonDataAnalysis.detectAnomalies(users);

  return {
    total_users: users.length,
    age_analysis: analysis,
    anomaly_detection: anomalies,
    pipeline: {
      step1: 'TypeScript SQL query',
      step2: 'Python statistical analysis',
      step3: 'Python anomaly detection',
    },
  };
}, {
  summary: 'Analyze users (Polyglot)',
  description: 'TypeScript SQL + Python data analysis',
});

/**
 * Generate report (TypeScript query + Python report generation)
 */
dbRouter.get('/users/report', async () => {
  // TypeScript: Database query
  const users = await db.query<any>('SELECT * FROM users');

  // Python: Generate formatted report
  const report = await PythonDataAnalysis.generateReport(users);

  return {
    report,
    format: 'text',
    generator: 'python-pandas',
  };
}, {
  summary: 'Generate user report',
});

/**
 * Complex aggregation (shows performance benefit)
 */
dbRouter.get('/analytics/summary', async () => {
  const start = Date.now();

  // TypeScript: Fast aggregation queries (parallel)
  const [userCount, avgAge, recentUsers] = await Promise.all([
    db.query<any>('SELECT COUNT(*) as count FROM users'),
    db.query<any>('SELECT AVG(age) as avg_age FROM users'),
    db.query<any>('SELECT * FROM users ORDER BY created_at DESC LIMIT 5'),
  ]);

  const queryTime = Date.now() - start;

  // Python: Analysis of recent users
  const analysisStart = Date.now();
  const analysis = await PythonDataAnalysis.analyzeAgeDistribution(recentUsers);
  const analysisTime = Date.now() - analysisStart;

  return {
    summary: {
      total_users: userCount[0]?.count || 0,
      average_age: avgAge[0]?.avg_age || 0,
      recent_users: recentUsers.length,
    },
    recent_user_analysis: analysis,
    performance: {
      query_time_ms: queryTime,
      analysis_time_ms: analysisTime,
      total_time_ms: queryTime + analysisTime,
    },
    architecture: {
      database_layer: 'typescript',
      analysis_layer: 'python',
    },
  };
}, {
  summary: 'Get analytics summary',
  description: 'Complex aggregation with polyglot analysis',
});

/**
 * Batch insert (TypeScript transaction)
 */
dbRouter.post('/users/batch', async (req) => {
  const users = req.body.users || [];

  // TypeScript: Efficient batch insert
  const result = await db.transaction(async () => {
    const inserted = [];

    for (const user of users) {
      await db.execute(
        'INSERT INTO users (email, age) VALUES ($1, $2)',
        [user.email, user.age]
      );

      inserted.push({
        email: user.email,
        age: user.age,
        created_at: new Date().toISOString(),
      });
    }

    return inserted;
  });

  return {
    inserted: result.length,
    users: result,
  };
}, {
  summary: 'Batch insert users',
  description: 'Efficient batch insert with transaction',
});

// Include router
app.include_router(dbRouter);

// Health check
app.get('/health', async () => {
  return {
    status: 'healthy',
    database: 'connected',
    timestamp: new Date().toISOString(),
  };
});

// Start server
if (require.main === module) {
  const PORT = 8006;
  app.listen(PORT, () => {
    console.log(`\n${'='.repeat(60)}`);
    console.log('  DATABASE ACCESS API - TypeScript + Python');
    console.log(`${'='.repeat(60)}\n`);
    console.log(`Server running at http://localhost:${PORT}`);
    console.log();
    console.log('Polyglot database architecture:');
    console.log('  üìä TypeScript: Fast SQL queries');
    console.log('  üêç Python: Advanced data analysis');
    console.log('  ‚ö° Shared: Zero-copy data transfer');
    console.log();
    console.log('Endpoints:');
    console.log(`  GET  http://localhost:${PORT}/db/users`);
    console.log(`  POST http://localhost:${PORT}/db/users`);
    console.log(`  GET  http://localhost:${PORT}/db/users/analyze`);
    console.log(`  GET  http://localhost:${PORT}/db/users/report`);
    console.log(`  GET  http://localhost:${PORT}/db/analytics/summary`);
    console.log();
    console.log(`API docs at http://localhost:${PORT}/docs`);
    console.log(`${'='.repeat(60)}\n`);
  });
}

export default app;
