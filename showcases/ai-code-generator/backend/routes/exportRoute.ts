/**
 * Export Route
 *
 * Handles project export as ZIP/TAR files
 */

import * as http from 'http';
import { validateExportRequest, sanitizeFilename } from '../utils/validators';
import { logger } from '../utils/logger';
import * as archiver from 'archiver';
import { PassThrough } from 'stream';

export async function handleExport(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: any
): Promise<void> {
  try {
    // Validate request
    const validation = validateExportRequest(body);
    if (!validation.valid) {
      res.writeHead(400, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        error: 'Validation failed',
        errors: validation.errors,
      }));
      return;
    }

    const { files, projectName, format, includeNodeModules } = body;
    const name = projectName || 'project';
    const exportFormat = format || 'zip';

    logger.info(`Exporting project: ${name} (${exportFormat})`);

    // Create archive
    const archive = createArchive(exportFormat);
    const passThrough = new PassThrough();

    // Set response headers
    res.writeHead(200, {
      'Content-Type': exportFormat === 'zip' ? 'application/zip' : 'application/x-tar',
      'Content-Disposition': `attachment; filename="${name}.${exportFormat}"`,
      'Cache-Control': 'no-cache',
    });

    // Pipe archive to response
    archive.pipe(passThrough);
    passThrough.pipe(res);

    // Add files to archive
    for (const file of files) {
      const safePath = sanitizeFilename(file.path);
      archive.append(file.content, { name: safePath });
    }

    // Add package.json if not present
    const hasPackageJson = files.some((f: any) => f.path === 'package.json');
    if (!hasPackageJson) {
      const packageJson = generatePackageJson(name, files);
      archive.append(JSON.stringify(packageJson, null, 2), { name: 'package.json' });
    }

    // Add README if not present
    const hasReadme = files.some((f: any) => f.path.toLowerCase().includes('readme'));
    if (!hasReadme) {
      const readme = generateReadme(name);
      archive.append(readme, { name: 'README.md' });
    }

    // Finalize archive
    await archive.finalize();

    logger.info('Project exported successfully');
  } catch (error) {
    logger.error('Export error:', error);
    if (!res.headersSent) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        error: 'Export failed',
        message: (error as Error).message,
      }));
    }
  }
}

/**
 * Create archive based on format
 */
function createArchive(format: string): any {
  // Simplified archiver - in production use actual archiver library
  // This is a mock implementation
  const stream = new PassThrough();
  const files: any[] = [];

  const archive = {
    pipe: (dest: any) => stream.pipe(dest),
    append: (content: string, opts: any) => {
      files.push({ content, name: opts.name });
    },
    finalize: async () => {
      // Mock ZIP creation
      const zip = createMockZip(files);
      stream.write(zip);
      stream.end();
    },
  };

  return archive;
}

/**
 * Create mock ZIP file
 */
function createMockZip(files: any[]): Buffer {
  // This is a simplified mock - in production use proper ZIP library
  const content = files.map(f => `${f.name}:\n${f.content}\n\n`).join('');
  return Buffer.from(content);
}

/**
 * Generate package.json
 */
function generatePackageJson(name: string, files: any[]): any {
  const hasReact = files.some((f: any) =>
    f.content.includes('import React') || f.content.includes('from "react"')
  );

  const hasVue = files.some((f: any) =>
    f.content.includes('import Vue') || f.content.includes('from "vue"')
  );

  const hasTypeScript = files.some((f: any) =>
    f.path.endsWith('.ts') || f.path.endsWith('.tsx')
  );

  const dependencies: Record<string, string> = {};
  const devDependencies: Record<string, string> = {};

  if (hasReact) {
    dependencies['react'] = '^18.2.0';
    dependencies['react-dom'] = '^18.2.0';
  }

  if (hasVue) {
    dependencies['vue'] = '^3.3.0';
  }

  if (hasTypeScript) {
    devDependencies['typescript'] = '^5.0.0';
    devDependencies['@types/node'] = '^20.0.0';
    if (hasReact) {
      devDependencies['@types/react'] = '^18.0.0';
      devDependencies['@types/react-dom'] = '^18.0.0';
    }
  }

  return {
    name: name.toLowerCase().replace(/\s+/g, '-'),
    version: '1.0.0',
    description: `Generated by AI Code Generator`,
    main: 'index.js',
    scripts: {
      start: hasTypeScript ? 'ts-node index.ts' : 'node index.js',
      build: hasTypeScript ? 'tsc' : 'echo "No build needed"',
      dev: hasTypeScript ? 'ts-node-dev index.ts' : 'nodemon index.js',
    },
    keywords: [],
    author: '',
    license: 'MIT',
    dependencies,
    devDependencies,
  };
}

/**
 * Generate README
 */
function generateReadme(name: string): string {
  return `# ${name}

Generated by AI Code Generator

## Installation

\`\`\`bash
npm install
\`\`\`

## Running

\`\`\`bash
npm start
\`\`\`

## Development

\`\`\`bash
npm run dev
\`\`\`

## Building

\`\`\`bash
npm run build
\`\`\`

---

Generated with ❤️ by AI Code Generator
`;
}
