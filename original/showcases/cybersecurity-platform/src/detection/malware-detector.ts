/**
 * Malware Detection Engine
 *
 * Multi-engine malware detection and analysis:
 * - Static analysis (PE parsing, string extraction, entropy)
 * - Dynamic analysis (behavior monitoring, sandbox)
 * - Machine learning classification (Random Forest)
 *
 * Features:
 * - PE file structure analysis
 * - Import/export analysis
 * - String and pattern extraction
 * - Entropy calculation
 * - Packer detection
 * - ML-based classification
 * - Malware family identification
 */

// @ts-ignore
import sklearn from 'python:sklearn';
// @ts-ignore
import numpy from 'python:numpy';
// @ts-ignore
import pefile from 'python:pefile';

import type {
  MalwareAnalysis,
  StaticAnalysis,
  DynamicAnalysis,
  MLClassification,
  MalwareDetectorConfig,
  PEHeader,
  PESection,
  ImportFunction,
  ExportFunction,
  StringAnalysis,
  SuspiciousIndicator,
} from '../types';

export class MalwareDetector {
  private config: Required<MalwareDetectorConfig>;
  private classifier: any;
  private featureExtractor: any;
  private sklearn: any;
  private yaraRules: any[];

  constructor(config: MalwareDetectorConfig) {
    this.config = {
      engines: config.engines,
      timeout: config.timeout ?? 300,
      sandbox: config.sandbox ?? false,
      yara: config.yara ?? false,
    };

    this.sklearn = sklearn;
    this.classifier = null;
    this.featureExtractor = null;
    this.yaraRules = [];
  }

  /**
   * Analyze file for malware
   */
  async analyzeFile(filepath: string): Promise<MalwareAnalysis> {
    console.log(`Analyzing file: ${filepath}`);

    const fs = require('fs');
    const crypto = require('crypto');
    const path = require('path');

    // Read file
    const fileBuffer = fs.readFileSync(filepath);
    const filename = path.basename(filepath);

    // Calculate hashes
    const md5 = crypto.createHash('md5').update(fileBuffer).digest('hex');
    const sha1 = crypto.createHash('sha1').update(fileBuffer).digest('hex');
    const sha256 = crypto.createHash('sha256').update(fileBuffer).digest('hex');

    // Determine file type
    const fileType = this.identifyFileType(fileBuffer);

    const analysis: MalwareAnalysis = {
      analysisId: this.generateAnalysisId(),
      filename,
      filepath,
      size: fileBuffer.length,
      fileType,
      md5,
      sha1,
      sha256,
      isMalware: false,
      confidence: 0,
      signatures: [],
      static: {
        sections: [],
        imports: [],
        exports: [],
        strings: {
          total: 0,
          suspicious: [],
          urls: [],
          ips: [],
          emails: [],
          registry: [],
          files: [],
        },
        entropy: 0,
        packers: [],
        antiVM: false,
        antiDebug: false,
        suspicious: [],
      },
      timestamp: Date.now(),
    };

    // Static analysis
    if (this.config.engines.includes('static')) {
      analysis.static = await this.performStaticAnalysis(fileBuffer, fileType);
    }

    // Dynamic analysis
    if (this.config.engines.includes('dynamic') && this.config.sandbox) {
      analysis.dynamic = await this.performDynamicAnalysis(filepath);
    }

    // ML classification
    if (this.config.engines.includes('ml') && this.classifier) {
      analysis.ml = await this.performMLClassification(analysis);
    }

    // Combine results
    analysis.isMalware = this.determineIfMalware(analysis);
    analysis.confidence = this.calculateConfidence(analysis);
    analysis.malwareFamily = this.identifyMalwareFamily(analysis);
    analysis.malwareType = this.identifyMalwareType(analysis);

    return analysis;
  }

  /**
   * Perform static analysis on file
   */
  private async performStaticAnalysis(
    fileBuffer: Buffer,
    fileType: string
  ): Promise<StaticAnalysis> {
    const analysis: StaticAnalysis = {
      sections: [],
      imports: [],
      exports: [],
      strings: {
        total: 0,
        suspicious: [],
        urls: [],
        ips: [],
        emails: [],
        registry: [],
        files: [],
      },
      entropy: 0,
      packers: [],
      antiVM: false,
      antiDebug: false,
      suspicious: [],
    };

    // Calculate entropy
    analysis.entropy = this.calculateEntropy(fileBuffer);

    // Extract strings
    analysis.strings = this.extractStrings(fileBuffer);

    // PE file analysis
    if (fileType === 'PE') {
      try {
        const pe = pefile.PE({ data: fileBuffer });

        // Parse PE header
        analysis.peHeader = this.parsePEHeader(pe);

        // Parse sections
        analysis.sections = this.parseSections(pe);

        // Parse imports
        analysis.imports = this.parseImports(pe);

        // Parse exports
        analysis.exports = this.parseExports(pe);

        // Detect packers
        analysis.packers = this.detectPackers(pe, analysis.sections);

        // Detect anti-VM techniques
        analysis.antiVM = this.detectAntiVM(analysis.imports, analysis.strings);

        // Detect anti-debug techniques
        analysis.antiDebug = this.detectAntiDebug(analysis.imports, analysis.strings);

        // Identify suspicious indicators
        analysis.suspicious = this.identifySuspiciousIndicators(analysis);
      } catch (error) {
        console.error('PE parsing failed:', error);
      }
    }

    return analysis;
  }

  /**
   * Perform dynamic analysis in sandbox
   */
  private async performDynamicAnalysis(filepath: string): Promise<DynamicAnalysis> {
    const analysis: DynamicAnalysis = {
      executionTime: 0,
      exitCode: 0,
      crashed: false,
      filesystem: [],
      network: [],
      registry: [],
      processes: [],
      memory: [],
      apiCalls: [],
    };

    // In a real implementation, this would execute the file in a sandbox
    // and monitor its behavior. For demonstration, we'll simulate some results.

    console.log(`Running dynamic analysis on ${filepath} (simulated)`);

    // Simulated behavior analysis
    analysis.executionTime = this.config.timeout;
    analysis.exitCode = 0;
    analysis.crashed = false;

    // Simulate detected behaviors
    analysis.filesystem = [
      {
        operation: 'create',
        path: 'C:\\Windows\\Temp\\malware.exe',
        timestamp: Date.now(),
        success: true,
      },
      {
        operation: 'write',
        path: 'C:\\Users\\User\\AppData\\config.dat',
        timestamp: Date.now(),
        success: true,
      },
    ];

    analysis.network = [
      {
        protocol: 'TCP',
        destination: '192.0.2.1',
        port: 443,
        bytes: 1024,
        timestamp: Date.now(),
      },
    ];

    analysis.registry = [
      {
        operation: 'create',
        key: 'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
        value: 'Malware',
        data: 'C:\\Windows\\Temp\\malware.exe',
        timestamp: Date.now(),
      },
    ];

    analysis.processes = [
      {
        pid: 1234,
        name: 'malware.exe',
        commandLine: 'C:\\Windows\\Temp\\malware.exe -silent',
        parentPid: 5678,
        startTime: Date.now(),
      },
    ];

    return analysis;
  }

  /**
   * Perform ML-based classification
   */
  private async performMLClassification(analysis: MalwareAnalysis): Promise<MLClassification> {
    const features = this.extractMLFeatures(analysis);
    const featureVector = Object.values(features);

    // Convert to NumPy array
    const X = numpy.array([featureVector]);

    // Predict
    const prediction = this.classifier.predict(X)[0];
    const probabilities = this.classifier.predict_proba(X)[0];

    const classification: MLClassification = {
      model: 'RandomForestClassifier',
      classification: prediction === 1 ? 'malicious' : 'benign',
      confidence: Math.max(...probabilities),
      features,
      probabilities: {
        benign: probabilities[0],
        malicious: probabilities[1],
      },
    };

    return classification;
  }

  /**
   * Train malware classifier
   */
  async trainClassifier(
    trainingData: any,
    options: {
      algorithm?: 'random-forest' | 'gradient-boosting' | 'svm';
      features?: string[];
      validation?: number;
    } = {}
  ): Promise<void> {
    console.log('Training malware classifier...');

    const algorithm = options.algorithm || 'random-forest';
    const validation = options.validation || 0.2;

    // Extract features and labels
    const X = trainingData.features;
    const y = trainingData.labels;

    // Split into train/test sets
    const trainTestSplit = this.sklearn.model_selection.train_test_split;
    const [XTrain, XTest, yTrain, yTest] = trainTestSplit(X, y, {
      test_size: validation,
      random_state: 42,
    });

    // Train classifier
    switch (algorithm) {
      case 'random-forest': {
        const RandomForestClassifier = this.sklearn.ensemble.RandomForestClassifier;
        this.classifier = new RandomForestClassifier({
          n_estimators: 100,
          max_depth: 10,
          random_state: 42,
        });
        break;
      }
      case 'gradient-boosting': {
        const GradientBoostingClassifier = this.sklearn.ensemble.GradientBoostingClassifier;
        this.classifier = new GradientBoostingClassifier({
          n_estimators: 100,
          learning_rate: 0.1,
          random_state: 42,
        });
        break;
      }
      case 'svm': {
        const SVC = this.sklearn.svm.SVC;
        this.classifier = new SVC({
          kernel: 'rbf',
          probability: true,
          random_state: 42,
        });
        break;
      }
    }

    this.classifier.fit(XTrain, yTrain);

    // Evaluate
    const score = this.classifier.score(XTest, yTest);
    console.log(`Classifier accuracy: ${(score * 100).toFixed(2)}%`);
  }

  /**
   * Classify file using trained model
   */
  async classifyFile(filepath: string): Promise<any> {
    const analysis = await this.analyzeFile(filepath);

    return {
      filepath,
      classification: analysis.isMalware ? 'malicious' : 'benign',
      confidence: analysis.confidence,
      isMalicious: analysis.isMalware,
      malwareFamily: analysis.malwareFamily,
      malwareType: analysis.malwareType,
      signatures: analysis.signatures,
    };
  }

  /**
   * Classify multiple files in batch
   */
  async classifyBatch(filepaths: string[]): Promise<any[]> {
    const results: any[] = [];

    for (const filepath of filepaths) {
      try {
        const result = await this.classifyFile(filepath);
        results.push(result);
      } catch (error) {
        console.error(`Failed to classify ${filepath}:`, error);
        results.push({
          filepath,
          error: String(error),
        });
      }
    }

    return results;
  }

  /**
   * Analyze file behavior (simulated sandbox)
   */
  async analyzeBehavior(
    filepath: string,
    options: {
      timeout?: number;
      network?: boolean;
      filesystem?: boolean;
      registry?: boolean;
    } = {}
  ): Promise<DynamicAnalysis> {
    return this.performDynamicAnalysis(filepath);
  }

  /**
   * Load training data from directories
   */
  async loadTrainingData(options: {
    malwarePath: string;
    benignPath: string;
    features?: string;
  }): Promise<any> {
    console.log('Loading training data...');

    // In a real implementation, this would load and extract features from files
    // For demonstration, return mock data structure

    return {
      features: numpy.random.rand(1000, 50), // 1000 samples, 50 features
      labels: numpy.concatenate([
        numpy.ones(500),  // 500 malware samples
        numpy.zeros(500), // 500 benign samples
      ]),
    };
  }

  // ============================================================================
  // Private Helper Methods
  // ============================================================================

  private identifyFileType(buffer: Buffer): string {
    // Check for PE signature
    if (buffer[0] === 0x4D && buffer[1] === 0x5A) {
      return 'PE';
    }

    // Check for ELF signature
    if (buffer[0] === 0x7F && buffer[1] === 0x45 && buffer[2] === 0x4C && buffer[3] === 0x46) {
      return 'ELF';
    }

    // Check for Mach-O signature
    if (buffer[0] === 0xFE && buffer[1] === 0xED && buffer[2] === 0xFA && buffer[3] === 0xCE) {
      return 'Mach-O';
    }

    return 'Unknown';
  }

  private calculateEntropy(buffer: Buffer): number {
    const frequency = new Map<number, number>();

    // Count byte frequencies
    for (let i = 0; i < buffer.length; i++) {
      const byte = buffer[i];
      frequency.set(byte, (frequency.get(byte) || 0) + 1);
    }

    // Calculate Shannon entropy
    let entropy = 0;
    for (const count of frequency.values()) {
      const probability = count / buffer.length;
      entropy -= probability * Math.log2(probability);
    }

    return entropy;
  }

  private extractStrings(buffer: Buffer): StringAnalysis {
    const strings: StringAnalysis = {
      total: 0,
      suspicious: [],
      urls: [],
      ips: [],
      emails: [],
      registry: [],
      files: [],
    };

    const text = buffer.toString('utf8', 0, Math.min(buffer.length, 1024 * 1024));

    // Extract printable strings
    const stringMatches = text.match(/[\x20-\x7E]{4,}/g) || [];
    strings.total = stringMatches.length;

    // Extract URLs
    const urlRegex = /https?:\/\/[^\s]+/g;
    strings.urls = Array.from(new Set(text.match(urlRegex) || []));

    // Extract IPs
    const ipRegex = /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g;
    strings.ips = Array.from(new Set(text.match(ipRegex) || []));

    // Extract emails
    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
    strings.emails = Array.from(new Set(text.match(emailRegex) || []));

    // Extract registry keys
    const registryRegex = /HKEY_[A-Z_]+\\[^\s]+/g;
    strings.registry = Array.from(new Set(text.match(registryRegex) || []));

    // Identify suspicious strings
    const suspiciousPatterns = [
      /password/i,
      /keylog/i,
      /ransomware/i,
      /bitcoin/i,
      /tor\s+browser/i,
      /rootkit/i,
      /backdoor/i,
    ];

    for (const str of stringMatches) {
      for (const pattern of suspiciousPatterns) {
        if (pattern.test(str)) {
          strings.suspicious.push({
            value: str,
            category: 'suspicious',
            offset: text.indexOf(str),
          });
        }
      }
    }

    return strings;
  }

  private parsePEHeader(pe: any): PEHeader {
    return {
      machine: pe.FILE_HEADER.Machine.toString(),
      numberOfSections: pe.FILE_HEADER.NumberOfSections,
      timeDateStamp: pe.FILE_HEADER.TimeDateStamp,
      characteristics: [],
      subsystem: pe.OPTIONAL_HEADER?.Subsystem?.toString() || 'Unknown',
      entryPoint: pe.OPTIONAL_HEADER?.AddressOfEntryPoint || 0,
      imageBase: pe.OPTIONAL_HEADER?.ImageBase || 0,
    };
  }

  private parseSections(pe: any): PESection[] {
    const sections: PESection[] = [];

    for (const section of pe.sections || []) {
      const sectionData = section.get_data();
      const entropy = this.calculateEntropy(Buffer.from(sectionData));

      sections.push({
        name: section.Name.toString().replace(/\0/g, ''),
        virtualAddress: section.VirtualAddress,
        virtualSize: section.Misc_VirtualSize,
        rawSize: section.SizeOfRawData,
        entropy,
        characteristics: [],
        suspicious: entropy > 7.0 || section.SizeOfRawData === 0,
      });
    }

    return sections;
  }

  private parseImports(pe: any): ImportFunction[] {
    const imports: ImportFunction[] = [];

    try {
      if (pe.DIRECTORY_ENTRY_IMPORT) {
        for (const entry of pe.DIRECTORY_ENTRY_IMPORT) {
          const dll = entry.dll.toString();

          for (const imp of entry.imports || []) {
            const funcName = imp.name?.toString() || `Ordinal_${imp.ordinal}`;

            imports.push({
              dll,
              function: funcName,
              suspicious: this.isSuspiciousImport(dll, funcName),
              category: this.categorizeImport(funcName),
            });
          }
        }
      }
    } catch (error) {
      // No imports or error parsing
    }

    return imports;
  }

  private parseExports(pe: any): ExportFunction[] {
    const exports: ExportFunction[] = [];

    try {
      if (pe.DIRECTORY_ENTRY_EXPORT) {
        for (const exp of pe.DIRECTORY_ENTRY_EXPORT.symbols || []) {
          exports.push({
            name: exp.name?.toString() || '',
            ordinal: exp.ordinal,
            address: exp.address,
          });
        }
      }
    } catch (error) {
      // No exports or error parsing
    }

    return exports;
  }

  private detectPackers(pe: any, sections: PESection[]): string[] {
    const packers: string[] = [];

    // Check for high entropy sections (indicator of packing)
    const highEntropySections = sections.filter((s) => s.entropy > 7.0);
    if (highEntropySections.length > 0) {
      packers.push('Unknown Packer (High Entropy)');
    }

    // Check for common packer section names
    const packerSectionNames = ['UPX0', 'UPX1', '.aspack', '.adata', 'MEW', '.mpress'];
    for (const section of sections) {
      for (const packerName of packerSectionNames) {
        if (section.name.includes(packerName)) {
          packers.push(packerName);
        }
      }
    }

    return Array.from(new Set(packers));
  }

  private detectAntiVM(imports: ImportFunction[], strings: StringAnalysis): boolean {
    const antiVMIndicators = [
      'VBoxService',
      'VMwareService',
      'vmmouse',
      'vmhgfs',
      'VirtualBox',
      'VMware',
    ];

    // Check imports
    for (const imp of imports) {
      if (imp.function.includes('CPUID') || imp.function.includes('QueryPerformance')) {
        return true;
      }
    }

    // Check strings
    for (const str of strings.suspicious) {
      for (const indicator of antiVMIndicators) {
        if (str.value.includes(indicator)) {
          return true;
        }
      }
    }

    return false;
  }

  private detectAntiDebug(imports: ImportFunction[], strings: StringAnalysis): boolean {
    const antiDebugAPIs = [
      'IsDebuggerPresent',
      'CheckRemoteDebuggerPresent',
      'NtQueryInformationProcess',
      'OutputDebugString',
    ];

    for (const imp of imports) {
      if (antiDebugAPIs.includes(imp.function)) {
        return true;
      }
    }

    return false;
  }

  private isSuspiciousImport(dll: string, func: string): boolean {
    const suspiciousAPIs = [
      'WriteProcessMemory',
      'VirtualAllocEx',
      'CreateRemoteThread',
      'SetWindowsHookEx',
      'GetAsyncKeyState',
      'InternetOpenUrl',
      'URLDownloadToFile',
      'WinExec',
      'ShellExecute',
    ];

    return suspiciousAPIs.includes(func);
  }

  private categorizeImport(func: string): string {
    if (func.includes('File') || func.includes('Read') || func.includes('Write')) return 'FileIO';
    if (func.includes('Process') || func.includes('Thread')) return 'ProcessManagement';
    if (func.includes('Registry') || func.includes('Reg')) return 'Registry';
    if (func.includes('Internet') || func.includes('Http')) return 'Network';
    if (func.includes('Crypt') || func.includes('Hash')) return 'Cryptography';
    return 'Other';
  }

  private identifySuspiciousIndicators(analysis: StaticAnalysis): SuspiciousIndicator[] {
    const indicators: SuspiciousIndicator[] = [];

    // High entropy
    if (analysis.entropy > 7.0) {
      indicators.push({
        type: 'entropy',
        description: 'High entropy indicates possible packing or encryption',
        severity: 'medium',
        confidence: 0.7,
      });
    }

    // Suspicious imports
    const suspiciousImports = analysis.imports.filter((i) => i.suspicious);
    if (suspiciousImports.length > 5) {
      indicators.push({
        type: 'imports',
        description: 'Multiple suspicious API imports detected',
        severity: 'high',
        confidence: 0.8,
      });
    }

    // Anti-VM
    if (analysis.antiVM) {
      indicators.push({
        type: 'anti-vm',
        description: 'Anti-VM techniques detected',
        severity: 'high',
        confidence: 0.9,
      });
    }

    // Anti-debug
    if (analysis.antiDebug) {
      indicators.push({
        type: 'anti-debug',
        description: 'Anti-debugging techniques detected',
        severity: 'high',
        confidence: 0.9,
      });
    }

    return indicators;
  }

  private extractMLFeatures(analysis: MalwareAnalysis): Record<string, number> {
    return {
      fileSize: analysis.size,
      entropy: analysis.static.entropy,
      sectionCount: analysis.static.sections.length,
      importCount: analysis.static.imports.length,
      exportCount: analysis.static.exports.length,
      suspiciousStrings: analysis.static.strings.suspicious.length,
      urlCount: analysis.static.strings.urls.length,
      ipCount: analysis.static.strings.ips.length,
      registryCount: analysis.static.strings.registry.length,
      antiVM: analysis.static.antiVM ? 1 : 0,
      antiDebug: analysis.static.antiDebug ? 1 : 0,
      packerDetected: analysis.static.packers.length > 0 ? 1 : 0,
      suspiciousImports: analysis.static.imports.filter((i) => i.suspicious).length,
    };
  }

  private determineIfMalware(analysis: MalwareAnalysis): boolean {
    // Use ML classification if available
    if (analysis.ml) {
      return analysis.ml.classification === 'malicious';
    }

    // Otherwise use heuristics
    let score = 0;

    if (analysis.static.entropy > 7.0) score += 20;
    if (analysis.static.antiVM) score += 30;
    if (analysis.static.antiDebug) score += 30;
    if (analysis.static.packers.length > 0) score += 25;
    if (analysis.static.suspicious.length > 3) score += 20;

    const suspiciousImports = analysis.static.imports.filter((i) => i.suspicious).length;
    if (suspiciousImports > 5) score += 30;

    return score >= 50;
  }

  private calculateConfidence(analysis: MalwareAnalysis): number {
    if (analysis.ml) {
      return analysis.ml.confidence;
    }

    // Calculate confidence based on indicators
    let confidence = 0.5;

    if (analysis.static.suspicious.length > 0) {
      confidence += 0.1 * Math.min(analysis.static.suspicious.length, 3);
    }

    if (analysis.static.antiVM || analysis.static.antiDebug) {
      confidence += 0.2;
    }

    return Math.min(confidence, 1.0);
  }

  private identifyMalwareFamily(analysis: MalwareAnalysis): string | undefined {
    // In a real implementation, this would use YARA rules or signature matching
    // For demonstration, return undefined
    return undefined;
  }

  private identifyMalwareType(analysis: MalwareAnalysis): any {
    const imports = analysis.static.imports.map((i) => i.function.toLowerCase());

    if (imports.some((i) => i.includes('crypt'))) {
      return 'ransomware';
    }

    if (imports.some((i) => i.includes('keylog') || i.includes('getasynckeystate'))) {
      return 'spyware';
    }

    if (imports.some((i) => i.includes('createremotethread') || i.includes('writeprocessmemory'))) {
      return 'trojan';
    }

    return undefined;
  }

  private generateAnalysisId(): string {
    return `ANALYSIS-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

export default MalwareDetector;
