/**
 * Vulnerability Scanner Service
 *
 * Security vulnerability scanning system with dependency scanning,
 * CVE matching, risk scoring, patch recommendations, and comprehensive
 * security report generation.
 */

import { serve } from "bun";
import { randomUUID } from "crypto";

// ============================================================================
// Types and Interfaces
// ============================================================================

type Severity = "critical" | "high" | "medium" | "low" | "info";
type ScanStatus = "pending" | "running" | "completed" | "failed";
type VulnerabilityStatus = "open" | "fixed" | "mitigated" | "accepted" | "false_positive";

interface Package {
  name: string;
  version: string;
  ecosystem: "npm" | "pypi" | "maven" | "nuget" | "go" | "cargo" | "composer";
  license?: string;
  description?: string;
}

interface CVE {
  id: string;
  publishedDate: Date;
  lastModifiedDate: Date;
  description: string;
  severity: Severity;
  cvssScore: number;
  cvssVector: string;
  cweIds: string[];
  references: string[];
  affectedVersions: string[];
  patchedVersions?: string[];
}

interface Vulnerability {
  id: string;
  package: Package;
  cve: CVE;
  detectedAt: Date;
  status: VulnerabilityStatus;
  riskScore: number;
  exploitAvailable: boolean;
  inProduction: boolean;
  remediation?: Remediation;
}

interface Remediation {
  recommendation: string;
  patchVersion?: string;
  workaround?: string;
  priority: Severity;
  effort: "low" | "medium" | "high";
  breakingChange: boolean;
}

interface ScanRequest {
  id: string;
  projectName: string;
  projectVersion: string;
  packages: Package[];
  createdAt: Date;
  status: ScanStatus;
  completedAt?: Date;
  error?: string;
}

interface ScanResult {
  id: string;
  scanId: string;
  projectName: string;
  projectVersion: string;
  scannedAt: Date;
  statistics: {
    totalPackages: number;
    vulnerablePackages: number;
    totalVulnerabilities: number;
    bySeverity: Record<Severity, number>;
    byStatus: Record<VulnerabilityStatus, number>;
  };
  vulnerabilities: Vulnerability[];
  riskScore: number;
  recommendations: string[];
}

interface SecurityReport {
  id: string;
  generatedAt: Date;
  summary: {
    totalProjects: number;
    totalScans: number;
    totalVulnerabilities: number;
    criticalVulnerabilities: number;
    highVulnerabilities: number;
    averageRiskScore: number;
  };
  trends: {
    period: string;
    newVulnerabilities: number;
    fixedVulnerabilities: number;
    riskScoreChange: number;
  };
  topVulnerabilities: Vulnerability[];
  topRiskyPackages: { package: Package; vulnerabilityCount: number }[];
}

// ============================================================================
// CVE Database (Mock)
// ============================================================================

class CVEDatabase {
  private cveData: Map<string, CVE[]> = new Map();

  constructor() {
    this.initializeMockData();
  }

  private initializeMockData(): void {
    // Mock CVE data for common packages
    this.cveData.set("express@4.17.1", [
      {
        id: "CVE-2022-24999",
        publishedDate: new Date("2022-11-26"),
        lastModifiedDate: new Date("2023-01-15"),
        description: "Express.js vulnerable to open redirect attacks via malicious URLs",
        severity: "medium",
        cvssScore: 6.1,
        cvssVector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
        cweIds: ["CWE-601"],
        references: [
          "https://nvd.nist.gov/vuln/detail/CVE-2022-24999",
          "https://github.com/advisories/GHSA-rv95-896h-c2vc",
        ],
        affectedVersions: ["<4.18.0"],
        patchedVersions: ["4.18.0"],
      },
    ]);

    this.cveData.set("lodash@4.17.20", [
      {
        id: "CVE-2021-23337",
        publishedDate: new Date("2021-02-15"),
        lastModifiedDate: new Date("2021-06-01"),
        description: "Command injection vulnerability in lodash template function",
        severity: "high",
        cvssScore: 7.2,
        cvssVector: "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
        cweIds: ["CWE-78", "CWE-94"],
        references: [
          "https://nvd.nist.gov/vuln/detail/CVE-2021-23337",
          "https://snyk.io/vuln/SNYK-JS-LODASH-1040724",
        ],
        affectedVersions: ["<4.17.21"],
        patchedVersions: ["4.17.21"],
      },
    ]);

    this.cveData.set("axios@0.21.0", [
      {
        id: "CVE-2021-3749",
        publishedDate: new Date("2021-08-31"),
        lastModifiedDate: new Date("2021-10-15"),
        description: "Axios vulnerable to server-side request forgery (SSRF)",
        severity: "high",
        cvssScore: 7.5,
        cvssVector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        cweIds: ["CWE-918"],
        references: [
          "https://nvd.nist.gov/vuln/detail/CVE-2021-3749",
          "https://github.com/axios/axios/security/advisories",
        ],
        affectedVersions: ["<0.21.2"],
        patchedVersions: ["0.21.2"],
      },
    ]);

    this.cveData.set("log4j@2.14.0", [
      {
        id: "CVE-2021-44228",
        publishedDate: new Date("2021-12-10"),
        lastModifiedDate: new Date("2022-01-20"),
        description: "Log4j remote code execution vulnerability (Log4Shell)",
        severity: "critical",
        cvssScore: 10.0,
        cvssVector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
        cweIds: ["CWE-502", "CWE-400"],
        references: [
          "https://nvd.nist.gov/vuln/detail/CVE-2021-44228",
          "https://logging.apache.org/log4j/2.x/security.html",
        ],
        affectedVersions: [">=2.0.0 <2.15.0"],
        patchedVersions: ["2.15.0"],
      },
    ]);

    this.cveData.set("django@3.1.0", [
      {
        id: "CVE-2021-35042",
        publishedDate: new Date("2021-07-02"),
        lastModifiedDate: new Date("2021-08-15"),
        description: "Django SQL injection vulnerability in QuerySet.order_by()",
        severity: "critical",
        cvssScore: 9.8,
        cvssVector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        cweIds: ["CWE-89"],
        references: [
          "https://nvd.nist.gov/vuln/detail/CVE-2021-35042",
          "https://www.djangoproject.com/weblog/2021/jul/01/security-releases/",
        ],
        affectedVersions: [">=3.0 <3.1.13", ">=3.2 <3.2.5"],
        patchedVersions: ["3.1.13", "3.2.5"],
      },
    ]);
  }

  public searchCVE(pkg: Package): CVE[] {
    const key = `${pkg.name}@${pkg.version}`;
    return this.cveData.get(key) || [];
  }

  public getCVEById(cveId: string): CVE | undefined {
    for (const cves of this.cveData.values()) {
      const cve = cves.find(c => c.id === cveId);
      if (cve) return cve;
    }
    return undefined;
  }
}

// ============================================================================
// Vulnerability Scanner
// ============================================================================

class VulnerabilityScanner {
  private cveDatabase: CVEDatabase;
  private scans: Map<string, ScanRequest> = new Map();
  private results: Map<string, ScanResult> = new Map();
  private vulnerabilities: Vulnerability[] = [];

  constructor() {
    this.cveDatabase = new CVEDatabase();
  }

  public async createScan(
    projectName: string,
    projectVersion: string,
    packages: Package[]
  ): Promise<ScanRequest> {
    const scan: ScanRequest = {
      id: randomUUID(),
      projectName,
      projectVersion,
      packages,
      createdAt: new Date(),
      status: "pending",
    };

    this.scans.set(scan.id, scan);

    // Start scan asynchronously
    this.executeScan(scan.id);

    return scan;
  }

  private async executeScan(scanId: string): Promise<void> {
    const scan = this.scans.get(scanId);
    if (!scan) return;

    try {
      scan.status = "running";

      const vulnerabilities: Vulnerability[] = [];

      for (const pkg of scan.packages) {
        const cves = this.cveDatabase.searchCVE(pkg);

        for (const cve of cves) {
          const vulnerability = this.createVulnerability(pkg, cve);
          vulnerabilities.push(vulnerability);
          this.vulnerabilities.push(vulnerability);
        }
      }

      const result = this.createScanResult(scan, vulnerabilities);
      this.results.set(result.id, result);

      scan.status = "completed";
      scan.completedAt = new Date();
    } catch (error) {
      scan.status = "failed";
      scan.error = error instanceof Error ? error.message : "Unknown error";
    }
  }

  private createVulnerability(pkg: Package, cve: CVE): Vulnerability {
    const riskScore = this.calculateRiskScore(cve);
    const exploitAvailable = Math.random() > 0.7; // 30% chance of public exploit
    const inProduction = Math.random() > 0.5;

    return {
      id: randomUUID(),
      package: pkg,
      cve,
      detectedAt: new Date(),
      status: "open",
      riskScore,
      exploitAvailable,
      inProduction,
      remediation: this.generateRemediation(pkg, cve),
    };
  }

  private calculateRiskScore(cve: CVE): number {
    // Risk score = CVSS base score * severity multiplier * exploit factor
    let score = cve.cvssScore;

    // Severity multiplier
    const severityMultiplier: Record<Severity, number> = {
      critical: 1.5,
      high: 1.3,
      medium: 1.1,
      low: 0.9,
      info: 0.5,
    };

    score *= severityMultiplier[cve.severity];

    // Normalize to 0-100
    return Math.min(100, Math.round(score * 10));
  }

  private generateRemediation(pkg: Package, cve: CVE): Remediation {
    const hasPatches = cve.patchedVersions && cve.patchedVersions.length > 0;

    return {
      recommendation: hasPatches
        ? `Upgrade ${pkg.name} to version ${cve.patchedVersions![0]} or later`
        : `No patch available. Consider alternative packages or apply workarounds`,
      patchVersion: hasPatches ? cve.patchedVersions![0] : undefined,
      workaround: !hasPatches
        ? "Review code for vulnerable usage patterns and implement input validation"
        : undefined,
      priority: cve.severity,
      effort: hasPatches ? "low" : "high",
      breakingChange: hasPatches && this.isBreakingChange(pkg.version, cve.patchedVersions![0]),
    };
  }

  private isBreakingChange(currentVersion: string, patchVersion: string): boolean {
    const current = currentVersion.split(".").map(Number);
    const patch = patchVersion.split(".").map(Number);

    // Major version change is breaking
    if (patch[0] > current[0]) return true;

    return false;
  }

  private createScanResult(scan: ScanRequest, vulnerabilities: Vulnerability[]): ScanResult {
    const statistics = this.calculateStatistics(scan.packages, vulnerabilities);
    const riskScore = this.calculateOverallRiskScore(vulnerabilities);
    const recommendations = this.generateRecommendations(vulnerabilities);

    return {
      id: randomUUID(),
      scanId: scan.id,
      projectName: scan.projectName,
      projectVersion: scan.projectVersion,
      scannedAt: new Date(),
      statistics,
      vulnerabilities,
      riskScore,
      recommendations,
    };
  }

  private calculateStatistics(
    packages: Package[],
    vulnerabilities: Vulnerability[]
  ): ScanResult["statistics"] {
    const vulnerablePackages = new Set(vulnerabilities.map(v => v.package.name));

    return {
      totalPackages: packages.length,
      vulnerablePackages: vulnerablePackages.size,
      totalVulnerabilities: vulnerabilities.length,
      bySeverity: {
        critical: vulnerabilities.filter(v => v.cve.severity === "critical").length,
        high: vulnerabilities.filter(v => v.cve.severity === "high").length,
        medium: vulnerabilities.filter(v => v.cve.severity === "medium").length,
        low: vulnerabilities.filter(v => v.cve.severity === "low").length,
        info: vulnerabilities.filter(v => v.cve.severity === "info").length,
      },
      byStatus: {
        open: vulnerabilities.filter(v => v.status === "open").length,
        fixed: vulnerabilities.filter(v => v.status === "fixed").length,
        mitigated: vulnerabilities.filter(v => v.status === "mitigated").length,
        accepted: vulnerabilities.filter(v => v.status === "accepted").length,
        false_positive: vulnerabilities.filter(v => v.status === "false_positive").length,
      },
    };
  }

  private calculateOverallRiskScore(vulnerabilities: Vulnerability[]): number {
    if (vulnerabilities.length === 0) return 0;

    const totalRisk = vulnerabilities.reduce((sum, v) => sum + v.riskScore, 0);
    const avgRisk = totalRisk / vulnerabilities.length;

    // Adjust for critical vulnerabilities
    const criticalCount = vulnerabilities.filter(v => v.cve.severity === "critical").length;
    const criticalBonus = criticalCount * 10;

    return Math.min(100, Math.round(avgRisk + criticalBonus));
  }

  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];

    const critical = vulnerabilities.filter(v => v.cve.severity === "critical");
    const high = vulnerabilities.filter(v => v.cve.severity === "high");

    if (critical.length > 0) {
      recommendations.push(
        `URGENT: Address ${critical.length} critical vulnerabilities immediately`
      );
    }

    if (high.length > 0) {
      recommendations.push(`High priority: Fix ${high.length} high-severity vulnerabilities`);
    }

    const withExploits = vulnerabilities.filter(v => v.exploitAvailable);
    if (withExploits.length > 0) {
      recommendations.push(
        `${withExploits.length} vulnerabilities have known public exploits - prioritize these`
      );
    }

    const inProduction = vulnerabilities.filter(v => v.inProduction);
    if (inProduction.length > 0) {
      recommendations.push(
        `${inProduction.length} vulnerabilities affect production packages`
      );
    }

    recommendations.push("Schedule regular dependency updates and security scans");
    recommendations.push("Implement automated dependency monitoring in CI/CD pipeline");

    return recommendations;
  }

  public getScan(scanId: string): ScanRequest | undefined {
    return this.scans.get(scanId);
  }

  public getResult(scanId: string): ScanResult | undefined {
    const result = Array.from(this.results.values()).find(r => r.scanId === scanId);
    return result;
  }

  public getVulnerabilities(filter?: {
    severity?: Severity;
    status?: VulnerabilityStatus;
    package?: string;
  }): Vulnerability[] {
    let filtered = [...this.vulnerabilities];

    if (filter?.severity) {
      filtered = filtered.filter(v => v.cve.severity === filter.severity);
    }

    if (filter?.status) {
      filtered = filtered.filter(v => v.status === filter.status);
    }

    if (filter?.package) {
      filtered = filtered.filter(v => v.package.name === filter.package);
    }

    return filtered.sort((a, b) => b.riskScore - a.riskScore);
  }

  public updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: VulnerabilityStatus
  ): boolean {
    const vulnerability = this.vulnerabilities.find(v => v.id === vulnerabilityId);
    if (!vulnerability) return false;

    vulnerability.status = status;
    return true;
  }

  public generateSecurityReport(): SecurityReport {
    const allResults = Array.from(this.results.values());
    const totalVulns = this.vulnerabilities.length;

    const criticalVulns = this.vulnerabilities.filter(v => v.cve.severity === "critical");
    const highVulns = this.vulnerabilities.filter(v => v.cve.severity === "high");

    const avgRiskScore =
      totalVulns > 0
        ? this.vulnerabilities.reduce((sum, v) => sum + v.riskScore, 0) / totalVulns
        : 0;

    // Calculate trends (mock data)
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    const newVulns = this.vulnerabilities.filter(v => v.detectedAt > weekAgo);

    // Top vulnerabilities by risk score
    const topVulns = [...this.vulnerabilities]
      .sort((a, b) => b.riskScore - a.riskScore)
      .slice(0, 10);

    // Top risky packages
    const packageVulnCount = new Map<string, { pkg: Package; count: number }>();
    for (const vuln of this.vulnerabilities) {
      const key = vuln.package.name;
      const existing = packageVulnCount.get(key);
      if (existing) {
        existing.count++;
      } else {
        packageVulnCount.set(key, { pkg: vuln.package, count: 1 });
      }
    }

    const topRiskyPackages = Array.from(packageVulnCount.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(item => ({ package: item.pkg, vulnerabilityCount: item.count }));

    return {
      id: randomUUID(),
      generatedAt: new Date(),
      summary: {
        totalProjects: new Set(allResults.map(r => r.projectName)).size,
        totalScans: this.scans.size,
        totalVulnerabilities: totalVulns,
        criticalVulnerabilities: criticalVulns.length,
        highVulnerabilities: highVulns.length,
        averageRiskScore: Math.round(avgRiskScore),
      },
      trends: {
        period: "Last 7 days",
        newVulnerabilities: newVulns.length,
        fixedVulnerabilities: this.vulnerabilities.filter(v => v.status === "fixed").length,
        riskScoreChange: 0, // Would calculate based on historical data
      },
      topVulnerabilities: topVulns,
      topRiskyPackages,
    };
  }
}

// ============================================================================
// HTTP Server
// ============================================================================

const scanner = new VulnerabilityScanner();

const server = serve({
  port: 3002,
  async fetch(req) {
    const url = new URL(req.url);

    // Health check
    if (url.pathname === "/health") {
      return Response.json({ status: "healthy", timestamp: new Date() });
    }

    // Create scan
    if (url.pathname === "/api/scans" && req.method === "POST") {
      const body = await req.json();
      const scan = await scanner.createScan(
        body.projectName,
        body.projectVersion,
        body.packages
      );
      return Response.json({ scan });
    }

    // Get scan status
    if (url.pathname.startsWith("/api/scans/") && req.method === "GET") {
      const scanId = url.pathname.split("/").pop()!;
      const scan = scanner.getScan(scanId);
      if (!scan) {
        return Response.json({ error: "Scan not found" }, { status: 404 });
      }
      return Response.json({ scan });
    }

    // Get scan results
    if (url.pathname.startsWith("/api/results/") && req.method === "GET") {
      const scanId = url.pathname.split("/").pop()!;
      const result = scanner.getResult(scanId);
      if (!result) {
        return Response.json({ error: "Results not found" }, { status: 404 });
      }
      return Response.json({ result });
    }

    // Get vulnerabilities
    if (url.pathname === "/api/vulnerabilities" && req.method === "GET") {
      const severity = url.searchParams.get("severity") as Severity | undefined;
      const status = url.searchParams.get("status") as VulnerabilityStatus | undefined;
      const packageName = url.searchParams.get("package") || undefined;

      const vulnerabilities = scanner.getVulnerabilities({
        severity,
        status,
        package: packageName,
      });

      return Response.json({ vulnerabilities, count: vulnerabilities.length });
    }

    // Update vulnerability status
    if (url.pathname.startsWith("/api/vulnerabilities/") && req.method === "PATCH") {
      const vulnId = url.pathname.split("/").pop()!;
      const body = await req.json();
      const success = scanner.updateVulnerabilityStatus(vulnId, body.status);
      return Response.json({ success });
    }

    // Generate security report
    if (url.pathname === "/api/reports/security" && req.method === "GET") {
      const report = scanner.generateSecurityReport();
      return Response.json({ report });
    }

    return Response.json({ error: "Not Found" }, { status: 404 });
  },
});

console.log(`üîç Vulnerability Scanner Service running on http://localhost:${server.port}`);
console.log(`üìä Endpoints:`);
console.log(`   POST   /api/scans                - Create new scan`);
console.log(`   GET    /api/scans/:id            - Get scan status`);
console.log(`   GET    /api/results/:scanId      - Get scan results`);
console.log(`   GET    /api/vulnerabilities      - Get vulnerabilities (filter: ?severity=critical&status=open)`);
console.log(`   PATCH  /api/vulnerabilities/:id  - Update vulnerability status`);
console.log(`   GET    /api/reports/security     - Generate security report`);
